---
layout: post
title: Today I Learned 📚
tags:
  - TIL
  - yagom-ios-camp-2nd
hero: https://source.unsplash.com/collection/11663747/
overlay: orange
published: true

---

{: .lead}
<!–-break-–>


# Today I Learned 🔥

## 2021.03.25 (목)

### 학습내용 📝

#### S.O.L.I.D.

##### SRP (단일책임의 원칙 : Single Responsibility Principle)

- 클래스는 한 가지 기능만 가지며 한 가지 책임을 수행하는 데 집중되어야 한다.

- 클래스가 변경되어야 할 여러 이유가 있는 경우(`뚱뚱해진 경우``) 너무 많은 책임을 부여하고 있는지 확인해보자.

- `SRP` 원칙을 따르면 클래스를 분할하여 유연하게 설계할 수 있는 장점이 있다.

  - 다른 행동, 책임이 분할되어 있어 연쇄적 사이트 이펙트가 발생할 여지가 줄어들어 그만큼 수정될 코드 또한 적다.
  - 너무 많은 분할로 인하여 책임이 파편화되는 경우 `Shotgun surgery`로 `응집력`을 높여주는 추가 작업이 필요할 수 있다.

  

  > Low Coupling
  >
  > - 여러 가지 책임으로 분할할 때는 책임간에 결합도를 최소화 해야 한다.
  >
  > High Cohesion
  >
  > - 하나에 여러 가지 책임이 있는 것의 반대인 상황으로 하나의 책임이 여러군데 분산되어 있는 상황이다.
  > - 하나의 수정사항이 여러 군데 영향을 미치는 경우 다시 하나로 모아 설계를 깔끔하게 유지 시켜주도록 해야 한다.

---



##### OCP (개방폐쇄의 원칙 : Open Close Principle)

- 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 `열려`있고, 변경에는 `닫혀`있어야 한다.
  - 변경에 대한 비용을 최대한 줄이면서 확장에 대해서는 가능한 극대화 해야 한다.
  - 다른 추가 사항이 있을 때 기존 구성은 변경하지 않고 확장에 대한 가능성을 열어줘야 한다.
- 컴파일 타입의 의존성을 인터페이스에 고정시키고 런타임 의존성을 변경시키게 함으로써 추가 클래스를 생성하여도 **동작은 추가**(`개방`) 되지만 기존의 **코드는 수정되지 않음**(`폐쇄`)을 의미한다.

> - 개방 폐쇄 원칙 OCP는 관리 가능(maintainable)하고, 재사용(resuable) 가능한 코드를 만드는 기반이다.
> - 잘 설계된 코드는 기존 코드의 변경 없이 확장 가능하다.
> - OCP를 가능하게 하는 중요 메커니즘은 추상화와 다형성이다.
>   - 추상화와 다형성을 가능하게 하는 키 메커니즘은 상속이다.
> - 추상 기반 클래스의 순수 가상 함수로부터 클래스를 상속 파생시킴으로써 추상화된 다형 인터페이스를 만들 수 있다.
>
> **로버트 C. 마틴**

---



##### LSP (리스코브 치환의 원칙 : The Liskov Substitution Principle)

- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
  - LSP는 사용자의 관점에서 기능에 영향을 미치지 않고, 서브 클래스를 부모 클래스로 대체 할 수 있어야 한다.

> - 객체지향을 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해
>   독립성을 보장할 수 있다.
> - 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.
>
> **로버트 C. 마틴**

---



##### ISP (인터페이스 분리의 원칙 : Interface Segregation Principle)

- 한 클래스는 자신이 사용하지 않는 `인터페이스`는 구현하지 말아야 한다.

  - 어떤 클래스가 다른 클래스를 상속받았을 때 최소한의 `인터페이스`만 사용해야 한다.
  - ISP는 일반적인 한 개의 `인터페이스`보다 구체적인 여러 가지의 `인터페이스`를 구현하는 원칙이다.

- SRP가 클래스의 `단일책임`을 강조한다면 ISP는 인터페이스의 `단일책임`을 강조한다.

- SRP의 목표는 `클래스 분리`를 통해 이뤄지고, ISP는 `인터페이스 분리`를 통해 이뤄진다.

  > - ISP에서 주의해야 할 사항은 기존 클라이언트에 변화를 주지 않으면서 인터페이스만을 분리하여 구현해야 한다는 점이다.
  > - 인터페이스를 분리함으로써 의존성을 약화시켜 리팩토링 및 구조 변경에 용이하게 만들어준다.

---



##### DIP (의존성 역전의 원칙 : Dependency Inversion Principle)

- 고수준 모듈은 저수준 모듈에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안되며, 추상화에 따라 달라진다.
- 전통적인 구조에서는 상위 레벨에서 하위 레벨에 의존하게 되어 하위 레벨에서 변경이 상위 레벨까지 전파된다.
- DIP는 각각의 클래스 또는 모듈 간의 의존성을 끊고 상위 레벨에서 정의한 추상을 하위레벨 모듈이 구현하게 하는 원칙으로 외부에서 의존성을 주입받아 Low Coupling을 만들게 하는게 목표이다.
  

---

### 문제점 / 고민한 점 🤦🏼

- if 문 지옥에 빠져있다....
- 동작 단위로 메소드를 나눠서 가독성을 확보해야 된다.
- 2진수 10진수 계산기를 공통된 부분을 활욜하기 위해서 설계를 해야한다. -> 프로포콜 

---

### 해결방법 🙋🏼

- ?..