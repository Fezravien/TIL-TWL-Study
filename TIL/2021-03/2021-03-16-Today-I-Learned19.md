---
layout: post
title: Today I Learned 📚
tags:
  - TIL
  - yagom-ios-camp-2nd
hero: https://source.unsplash.com/collection/4585827/
overlay: orange
published: true

---

{: .lead}
<!–-break-–>

# Today I Learned 🔥

## 2021.03.16 (화) 🗓

### 학습내용 📝

#### 커스터마이징

##### 커스터마이징의 개념

iOS 프로그래밍에서 유저 인터페이스 구현의 꽃으로 일컬어지는 커스터마이징은, 기본 기능에 만족하지 않고 객체의 제약을 벗어나 **원하는 대로 자유롭게 기능을 확장할 수 있는 기능**이라고 할 수 있다.

##### iOS 프로그래밍에서 UI 커스터마이징이란?

- 커스터마이징은 "커스텀화하다" 라는 의미로, **우리가 원하는 대로 수정하거나 기능을 변경한다**는 의미를 가진 단어이다.
- IT에서는 주로 주어진 라이브러리나 프레임워크를 수정하여 사용한다는 의미로 사용되지만, 버그를 고치기 위함이 아니라 요구사항을 만족시키기 위해 수정하는 것을 가리킨다.

---

##### iOS의 화면 표현 구조 

- `윈도우`는 iOS에서 디바이스의 스크린을 빈틈없이 채우기 위한 객체로, 항상 유저 인터페이스 표현 계층의 최상위에 위치한다.

- 뷰의 일종이지만 직접 콘텐츠를 가지지는 않으며 콘텐츠를 가진 뷰를 내부에 배치하여 화면에 출력하는 역할만 한다.

- 화면이 전환되더라도 단지 윈도우 내부에 배치된 뷰 콘텐츠만 변경될 뿐, 윈도우 객체 자체는 전환되지 않는다.

  

- 뷰는 콘텐츠를 담아 이를 스크린 상에 표시하고, 사용자의 입력에 반응하는 객체이다.

- `윈도우`의 일부를 자신의 영역으로 정의하고, 여기에 필요한 콘텐츠를 채워넣어 스크린에 나타내는 동시에, 윈도우로부터 전달된 사용자의 입력에 반응하여 그에 맞는 결과를 처리한다.

  

- iOS에서 실행되는 모든 애플리케이션에는 최소한 하나 이상의 윈도우와 뷰가 존재한다. (대부분 하나의 윈도우)

- 윈도우와 뷰 사이는 뷰 컨트롤러를 통해 연결된다.

  

- 루트 뷰 컨트롤러로 지정되지 못한 나머지 뷰 컨트롤러들은 루트 뷰 컨트롤러의 제어 대상으로 연결되거나 혹은 다른 방식으로 이어지기도 하지만, 이들을 윈도우 객체의 직접적인 관리 대상이 아니다. 

- 윈도우 객체는 항상 루트 뷰 컨트롤러만을 참조하고, 관리한다. 쉽게 말하자면 루트 뷰 컨트톨러는 윈도우와 연결하기위한 뷰 컨트롤러 집단의 대표같은 것 이다.

  

- UIKit 프레임워크는 버튼이나 레이블, 텍스트 필드와 같은 비교적 단순한 컨트롤뿐만 아니라 테이블 뷰나 이미지 뷰, 스크롤 뷰 등 복잡한 구조의 뷰에 이르기까지 다양한 종류의 뷰를 미리 정의하여 제공한다.

- 앱을 만들기 위한 UI 요구사항은 너무 제각각이어서, 프레임워크에서 제공하는 기본 객체만으로는 원하는 유저 인터페이스를 구현할 수 없는 경우도 종종 발생한다.

  - 이때에는 객체의 속성을 직접 제어하여 원하는 기능을 구현하거나, 이것이 여의치 않을 경우 커스텀 객체를 직접 제작하여 필요한 기능을 구현해야한다. -> 커스터마이징



##### 코코아 터치 프레임워크와 사용자 인터페이스

코코아 터치 프레임워트킄 크게 `파운데이션(Foundation) 프레임워크`와 `UIKit 프레임워크`로 이뤄진다.

- `파운데이션 프레임워크`는 애플리케이션의 중심이자 기능적인 면을 담당하는 프레임워크로, `기본 자료형을 포함한 자료구조`,`객체 지향 처리와 연산`, 그리고 `각종 구조체`나 `타이머`, `네트워크 통신` 등 모바일 애플리케이션으로서의 특징적 기능에 직접 연관되지 않은 대부분의 기본적인 애플리케이션 기능을 처리한다.
  - 프레임워크에 속한 객체들은 이름이 모두 `NS`라는 키워드로 시각한다. 다만 최근에 와서는 스위프트용으로 사용되는 일부 객체의 이름에서 `NS` 키워드를 걷어내고 있기 때문에 다소 주의가 필요하다.
- 공통적인 기능을 처리하는 `파운데이션 프레임워크`와 달리 `UIKit 프레임워크`는 `화면`이나 `유저 인터페이스`, 앱의 `동작` 등 모바일 애플리케이션으로서의 기능 구현을 주로 담당하는 프레임워크이다.
  - 화면에 표현되는 각종 콘텐츠나 컨트롤 객체를 보유하고 있으며, 화면의 구조를 만들고 관리할 뿐만 아니라 화면과 사용자의 상호반응, 모바일 디바이스의 화면 변경에 따른 이슈까지 처리한다.
  - 우리가 앱의 특성이라고 생각하는 대부분의 기능 구현에는 `UIKit 프레임워크`가 관여한다고 생각하면 된다.

---

##### 뷰 컨트롤러 (View Controller)

`뷰 컨트롤러(VIew Controller)`는 앱의 근간을 이루는 객체로, 모든 앱은 적어도 하나 이상의 뷰 컨트롤러로 구성된다. 	

- 콘텐츠 뷰 컨트롤러

  - 각종 콘텐츠를 얹어 화면에 출력한다.

    1. 테이블 뷰 컨트롤러 (UITableVeiwController)

    2. 컬렉션 뷰 컨트롤러 (UICollectionViewController)

    3. 스크롤 뷰 컨트롤러 (UIScrollViewController)

    4. 일반 뷰 컨트롤러 (UIViewController)

       

- 컨테이너 뷰 컨트롤러 

  - 뷰 컨트롤러와 뷰 컨트롤러의 연결 관계를 관리하는 컨트롤러이다.
    1. 내비게이션을 이용하여 다음 화면을 단계적으로 접근하는 방식 (내비게이션 컨트롤러)
    2. 탭을 이용하여 병렬적으로 접근하는 방식 (탭 바 컨트롤러 )
    3. 메인 화면과 디테일 화면으로 나누어 접근하는 방식 (분할 뷰 컨트롤러)
    4. 페이지 뷰 컨트롤러



##### 뷰 (View)

`뷰`는 콘텐츠를 표현하는 객체이자 동시에 다른 서브 뷰를 포함하는 컨테이너이다.

- 뷰가 없으면 화면에는 아무것도 표시할 수 없다.

- `보여주기`에 관련된 기능들은 모두 `UIVIew` 클래스를 통해 처리한다.

  ```swift
  let mainTitle = UILabel()
  self.view.addSubview(mainTitle)
  ```

  이 코드는 메인 타이틀 역할을 할 레이블 객체를 정의하고, 이를 화면에 표시하는 과정을 프로그래밍 방식으로 구현하는 예제이다.

  - addSubView(_:) 
    - 인자값으로 입력된 객체를 슈퍼 뷰에 추가해주는 역할
    - 매개 변수는 UIView 타입
    - 우리가 레이블이나 버튼, 스위치 등의 객체를 화면에 표현할 수 있는 것은 이들 객체가 모두 UIView 클래스를 상속받은 서브 뷰의 일종이기 때문이다.

---

##### 뷰의 위치와 CGPoint 구조체

위치를 나타낼 때 CGPoint 구조체를 사용한다.

- y 축 

  - 좌측 상단 ~ 하단 

- x 축

  - 좌측 상단 ~ 우측 상당 

  

##### 뷰의 크기와 CGSize 구조체

너비와 높이를 표현한다.



##### CGRect

뷰의 위치와 크기를 한 번에 표현하기 위해서는 CGRect 구조체를 사용한다.

---

##### Frame과 Bounds 속성

- `frame`

  - 뷰의 위치와 크기를 지정하는 데에 사용되는 속성이다.

  - 읽기와 쓰기 모두 허용 

  - UIView 클래스는 frame 속성을 인자값으로 하는 초기화 메소드를 제공한다.

    ```swift
    public init(frame: CGRect)
    
    let view = UIVIew()
    view.frame = CGRect(x: 50, y: 70, width: 90, height: 130)
    ```

  - 실제로 옮겨진 뷰의 위치를 계산할 때에는 주의해야한다.

    - frame 속성의 좌표값이 `가리키는 위치는 자신의 상위 뷰를 기준으로 하는 상대적인 값`이기 때문인다.

  - 왜 frame 처럼 뷰의 위치 속성에 `상대 좌표계`를 적용할까?

    - 상대 좌표 체계가 다루기 더 쉬울 뿐만 아니라 여러 상황에 유연하게 대응할 수 있기 때문이다.
    - 루트 뷰의 서브 뷰에서 수정을 한다면 서브 뷰에 포함된 서브 뷰 전체를 바꿀 수 있다.

  - 어디에 사용될까?

    - 뷰 자신의 위치나 크기 등 영역을 설정하는 경우에 사용된다.

    

- `bounds`

  - 좌표 기준은 자기 자신이다.

  - 뷰의 내부에 있는 객체와의 관계에서 사용된다.

    - 주로 뷰 내부에 서브 뷰를 추가하기 위해 (0, 0)의 원점 좌표가 필요할 때, 혹은 뷰 내에서 터치 이벤트가 발생한 위치를 판별해야 할 때

      

- 정리!!!

  - 슈퍼 뷰가 서브 뷰에게 제공하는 좌표는 `bounds` 속성의 좌표
    - 자식 뷰가 기준으로 삼는 부모 뷰의 좌표 속성
    - 이 같은 특성을 이용하면 외부 뷰는 그대로 둔 채 내부 뷰만 위치를 이동시키거나 스크롤 기능을 처리하도록 할 수도 있다.
    - 주로 이미지 뷰어에서 큰 이미지를 드래그해서 볼 수 있도록 처리할 때 사용하는 방법
  - 서브 뷰는 이 좌표를 기준으로 자신의 `frame` 속성을 설정



---

### 문제점 / 고민한 점 🤦🏼

- Notification Center의 생성과 소멸은 어느 시기에 이뤄지는게 좋을까?



### 해결방법 🙋🏼

- 명확한 해답은 아니지만 이렇게 생각했다 !
  - 생성 : viewWillAppear
  - 소멸 : viewWillDisappear
    - 초기값을 viewDidLoad에서 업데이트를 해주니 메모리를 생각해서 옵져버를 viewWillAppear에 설치
    -  viewWillAppear는 화면 전환시 마다 호출 되므로 소멸은 viewWillDisappear에서 하도록 했다. (화면이 전환된 상태에서 지속적인 라벨 업데이트 막기)