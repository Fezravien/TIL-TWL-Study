---
layout: post
title: Today I Learned 📚
tags:
  - til
  - yagom-ios-camp-2nd

hero: https://source.unsplash.com/collection/5058541/
overlay: orange
published: true

---

{: .lead}
<!–-break-–>

# Today I Learned 🔥



## 2021.03.04 (목)



### 학습내용

#### HIG (Human Interface Guidelines)

##### Modality

<img src="https://blog.kakaocdn.net/dn/bNDioO/btqEzefGjbQ/6cwKyoXqKopcjIK7Q7VlbK/img.png" alt="img" style="zoom:40%;" />

모달리티는 사용자의 이전과 현재 페이지를 분리하여 임시로 콘텐츠를 나타내는 설계 기술이다. 

- 사용자가 특정한 작업 또는 밀접하게 관련된 옵션들을 집중할 수 있도록 돕는다.
- 중요한 정보에 있어서 사용자가 수신하고, 필요하다면 행동까지 보장한다.



##### Sheet

sheet presentation 스타일은 기본 콘텐츠를 부분적으로 커버하는 카드로 나타내며, 보여지지 않는 모든 영역을 흐리게 하여 해당 역역과의 상호 작용을 방지한다. 상위 뷰 또는 이전 카드의 윗쪽 가장자리가 현재 카드 뒤에 표시되어 카드를 열 때 일시 중당했던 작업을 기억할 수 있게 돕는다. 다음 방법으로 카드를 해제한다.

<img src="https://www.appcoda.com/learnswiftui/images/bottom-sheet/swiftui-bottom-sheet-2.png" alt="Building an Expandable Bottom Sheet with SwiftUI Gestures and  GeometryReader · Mastering SwiftUI Book - Sample" style="zoom:40%;" />

- 화면의 상단에서 아래로 스와이프
- 카드 콘텐츠가 맨 위로 스크롤될 때, 화면의 아무 곳에서나 아래로 스와이프
- 버튼 탭 하기

**복잡한 작업을 활성화하지 않는 모달 컨텐츠의 경우 시트를 사용하세요 ! **



##### Fullscreen

fullscreen 스타일은 전체 화면을 커버한다. 이전의 뷰는 완전히 가려지고, 시각적 방해를 최소화한다.

**동영상, 사진 또는 카메라 뷰와 같은 몰입형 콘텐츠 또는 전체 화면 프레젠테이션(예: 문서 표시 또는 사진 편집)의 이점을 제공하는 복잡한 작업에 전체 화면 모달 뷰를 사용하세요 !**



##### 이럴때 사용하세요 !

- 이해가 될 때 모달을 사용하세요 !

  - 현재의 작업과 다른 작업을 수행하거나 선택하여 사용자의 주의를 집중시키는 것이 중요한 경우에만 모달 경험을 생성하기

  - 모달 경험은 사용자에게 현재 상황을 벗어나고 무시하는 행동을 요구하므로, 모달이 명확한 유익(장점)을 제공하는 경우에만 사용

    

- 모달 작업은 `간단`하고, `짧게` 그리고 `주의깊게(narrowly)` 집중되도록 하세요 !

  - 앱 내에서 앱 만드는 것을 피하기

    - 모달 작업이 너무 복잡하면, 사용자들은 모달 상황을 마주할 때, 기존의 하고 있던 작업의 집중이 흐트러질 수 있다.

    - 특히 뷰의 계층이 포함되어 있는 모달 작업을 생성할 때 주의

      - 사용자가 되돌아가는 방법을 잃거나 잊어버릴 수 있음

    - 현재 사용자가 어디에 있는 지 알 수 있도록 표시한 `path` 와 완료까지의 명확한 `path` 를 제공하기

    - 작업을 완료하는 것 외에는 완료(Done) 버튼을 제공하지 말기

      

-  모달 뷰를 끝내는 버튼을 항상 포함하세요 !

  - `Done`, `Cancel` 사용하기

    - 버튼을 포함하는 것은 모달 뷰가 보조의 기술에 접근 가능할 수 있도록 도와주고, 그만두는 행동에 대안을 제공

    

-  필요할때, 모달 뷰를 닫기 전에 사용자에게 동의를 구하면서 데이터가 손실되는 것을 도와주세요 !

  - 사용자가 그만두는 제스터를 취하거나 뷰를 닫는 버튼을 사용에 상관없이 데이터 손실이 발생할 수 있다면, 사용자에게 상황을 설명하고 해결하는 방법을 알려주는 `action sheet` 를 띄워주기

    

- 팝업 표시 위에 나타나는 카드를 표시하지 마세요 !

  - 팝업 표시 내에 카드를 표시할 수 있지만, 팝업 표시 위에 아무 것도 표시되지 않아야 합니다(경고일 수 있음). 드문 경우이긴 하지만, 사용자가 팝업 표시에서 작업을 수행한 후 카드를 표시해야 하는 경우에는 카드를 표시하기 전에 팝오버를 닫기

    

- 모달에서 진행되는 일을 확인할 수 있는 제목을 보여주세요 !

  - 모달 작업을 시작할 때 이전 환경에서 벗어나므로 새로운 환경을 명확히 하는 것이 좋습니다. 또한 작업을 더 자세히 설명하거나 지침을 제공하는 텍스트를 보기의 다른 부분에 제공할 수도 있다.

    

- 모달 뷰의 디자인을 앱에 맞게 조정하세요 !

  - 모달 뷰가 내비게이션 바를 포함할 때, 앱에서도 내비게이션 바와 같은 디자인을 사용해야 한다.

    

- 앱에서 이해할 수 있는 모달 변경 스타일을 선택하세요 !

  - 앱에 맞는 화면 변경 스타일을 사용하고, 일시적으로 환경이 변경되도 사용자가 인지할 수 있게 하기 
  - 앱 전체적으로 일관된 모달 화면 변경 스타일을 사용하기

---

### 문제점 / 고민한 점 🤦🏼

- 클래스, 구조체

  - **클래스와 구조체는 프로그램의 코드를 조직화 하기 위해 일반적으로 사용합니다.**

  - 클래스와 구조체는 많은 공통점이 있습니다.

    - 값을 저장하기 위한 프로퍼티 정의

    - 기능을 제공하기 위한 메소드 정의

    - `subscript` 문법을 이용해 특정 값을 접근할 수 있는 `subscript` 정의

    - 초기 상태를 설정할 수 있는 `initializer` 정의

    - 기본 구현에서 기능 확장

    - 특정한 종류의 표준 기능을 제공하기 위한 프로토콜 순응(conform)

      

  - 구조체로는 가능하지 않고 클래스만 가능한 기능은 아래와 같습니다.

    - 상속 (Inheritance) : 클래스의 여러 속성을 다른 클래스에 물려 줌

    - 타입 캐스팅 (Type casting) : 런타임에 클래스 인스턴스의 타입을 확인

    - 소멸자 (Deinitializers) : 할당된 자원을 해제(free up) 시킴

    - 참조 카운트 (Reference counting) : 클래스 인스턴스에 하나 이상의 참조가 가능

      

- 열거형 

  - **열거형은 관련된 값으로 이루어진 그룹을 공통의 형으로(type) 선언해 형 안전성(type-safety)을 보장하는 방법으로 코드를 다룰 수 있게 해줍니다.**

  - `CustomStringConvertible` 프로토콜을 준수하는 유형은 인스턴스를 문자열로 변환할 때 사용할 고유한 표현을 제공할 수 있습니다.

    ```swift
    struct Point {
        let x: Int, y: Int
    }
    
    let p = Point(x: 21, y: 30)
    print(p)
    // Prints "Point(x: 21, y: 30)"
    ```

    ```swift
    extension Point: CustomStringConvertible {
        var description: String {
            return "(\(x), \(y))"
        }
    }
    
    print(p)
    // Prints "(21, 30)"
    ```

    

---

### 해결방법 🙋🏼

```swift
enum A: Int {
  case a = 1
  case b = 2
  case c = 3
  ...
}

struct B {
  let apple = A.a.rawValue
  let banana = A.b.rawValue
  let cacao = A.c.rawvalue
  ...
}

struct AB {
  let apple = 1
  let banana = 2
  let cacao = 3
  ...
}
```

- 열거형 A의 원시값을 사용하기 위해 구조체 B를 가져오는 코드를 짜고 나니 이상한 중복을 하고 있다는 생각을 가지게 되었고, 열거형을 활용하고 있다기보다 단순하게 값들을 정리하고 있다고 판단하여 열거형을 구조체로 통합시켜서 해결했다. 

- 열거형을 활용하고 싶다면 `CustomStringConvertible` 프로토콜과 `스위치`를 이용하면 좀 더 나은 결과가 있을 것 같다.

