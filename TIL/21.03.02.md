

# Today I Learned 🔥



## 2021.03.01 (월) 🗓



### 학습내용 📝

#### guard ?

- `빠른 종료`의 핵심 키워드
- if 구문과 유사하게 `Bool 타입의 값`으로 동작하는 기능이다.
- if 구문과 다르게 항상 `else` 구문이 따라와야 한다.
- `else` **구문의 블록 내부에는 꼭 자신보다 상위의 코드 블록을 종료하는 코드가 들어가야 한다.**
  - 특정 조건에 부합하지 않다는 판단이 되면 재빠르게 코드 블록의 실행을 종료 
  - `return`, `break`, `continue`, `throw` 등 제어문 전환 명령어를 사용한다. 
    - 제어문 전환 명령어를 쓸 수 없는 상황이라면 사용이 불가능하다.
    - 함수나 메서드, 반복문 등 특정 블록 내부에 위치하지 않는다면 사용이 제한된다.
  - 또는 `fatalError()`와 같은 비반환 함수나 메서드를 호출할 수도 있다.
- if 코드를 훨씬 간결하고 읽기 좋게 구성할 수 있다.
  - if 구문을 사용하면 예외사항을 else 블록으로 처리해야 하지만 예외사항만을 처리하고 싶다면 `guard` 구문이 훨씬 간편하다.
- Bool 타입의 값으로 `guard` 구문을 동작시킬 수 있지만, 옵셔널 바인딩의 역할도 한다.



#### Recursion vs Iteration

##### 재귀와 반복의 주요 차이점 

- 재귀는 프로그램의 메소드가 반복적으로 자신을 호출하는 반면, 반복은 프로그램의 명령어 세트가 반복적으로 실행되는 경우이다.
- 재귀 적 메소드에는 일련의 명령어, 명령문 호출 자체 및 종료 조건이 포함되지만 반복문에는 초기화, 증가, 조건, 루프 내의 명령어 세트 및 제어 변수가 포함한다.
- 조건문은 재귀의 종료를 결정하고 변수의 값을 제어하여 반복문의 종료를 결정한다.
- 메서드가 종료 조건으로 이어지지 않으면 무한 재귀에 들어갑니다. 반면에 제어 변수가 종료 값으로 연결되지 않으면 반복문이 무한 반복된다.
- 무한 재귀은 시스템 충돌로 이어질 수 있지만 무한 반복은 CPU 사이클을 소모하다.
- 재귀는 항상 메소드에 적용되는 반면, 반복은 명령어 세트에 적용된다.
- **재귀 중에 작성된 변수는 스택에 저장되지만 반복에는 스택이 필요하지 않다.**
- **재귀 호출은 반복되는 함수 호출의 오버 헤드를 유발하는 반면, 반복에는 오버 헤드를 호출하는 함수가 없다.**
- 함수 호출로 인해 재귀 실행은 느려지는 반면 반복 실행은 빠르다.
- 재귀는 코드의 크기를 줄이지 만 반대로 반복은 코드를 길게 만든다.



#### 예외처리 (throws, do-catch, try) 하기

오류 처리에는 다음 세 가지 과정이 필요하다

1. 오류의 종류 정의하기
2. 발생한 오류 던지기
3. 던진 오류 처리하기



##### 1. 오류의 종류 정의하기 

먼저 오류의 종류를 정의해준다 (열거형 Error 프로토콜 받기!)

```swift
enum 오류종류이름 : Error {
     case 종류1 
     case 종류2 
       .
}
// 예시
enum TestError : Error {
     case outOfRange                       
}
```



##### 2. 발생한 오류 던지기

오류는 **throws** 를 이용해 던진게 된다. 

> 오류를 던진다 = 오류를 처리해주는 곳으로 전달한다

```swift
func throwError() -> throws Bool {
  let optionalString = readLine()
  guard let someError = optionalString else {
    throw TestError.outOfRange
  }
} 
```

guard문에서 오류 발생시 throw 를 통해 던질 수 있다. (메소드 옆에 throws - 던질 수 있는 메소드!)



##### 3. 던진 오류 처리하기

오류 처리는 **try**와 **do-catch**로 한다.



```swift
class Object {
  func throwError() -> throws Bool {
    let optionalString = readLine()
    guard let someError = optionalString else {
      throw TestError.outOfRange
    }
  } 
}

do {
	let catchError = try Object().throwError()  
} catch {
  // 오류처리
  
}
```

try : 오류가 발생할 수도 있다 ! 하지만 시도는 해볼게 !!



##### try?와 try!

`try는 try?나 try!로 쓸 수 있다`

- try?

오류가 발생할 수도 있다는 걸 인정하는 겁니다.

Swift에서 물음표는 옵셔널을 의미하죠.

따라서 옵셔널 타입 또는 nil로 받을 수 있게 됩니다.

- try!  `자.신.있.어 ?`

메소드에서 오류가 절!대! 발생하지 않을 `자신이 있으면` 씁니다. 

오류발생 시 Runtime Error가 발생하고 강제종료됩니다.



> 출처 
>
> [재귀와 반복의 차이점](https://ko.gadget-info.com/difference-between-recursion)
>
> [예외처리](https://twih1203.medium.com/swift-예외처리-throws-do-catch-try-하기-c0f320e61f62)



---

### 문제점 / 고민한 점 🤦🏼 / 해결방법 🙋🏼

- 옵셔널 바인딩을 시도할때 if let, 예외처리가 있는 조건문을 if으로 사용한 부분을 프로젝트 리뷰를 통해 다시한번 생각해보게 되었고 상황이 guard가 더 적합하다는 사실을 알게 되었다. 또한 guard의 예외처리 (throw)를 하기위해 열거형을 활용하여 수정했더니 코드의 길이가 확실히 줄었다.
  - 옵셔널 바인딜에 있어서 `if let`, `guard`를 잘보고 사용하자 👊
- 재귀함수와 반복문,,,,, 재귀가 코드가 간결하게 보여 사용했지만 스택에 쌓여있는(?) 문제점이 생겼다 (dump)-> 진 행 중 ⏱

---

### 

