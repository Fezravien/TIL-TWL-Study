# Today I Learned 🔥

---

## 2021.02.26 (금)

---

### 학습내용

- 옵셔널

  - swift 메모리 처리 -> 빈 공간이 없게 !

  - 메모리 공간에 변수명과 같은 크기 또는 조금 더 크게 옵셔널 상자를 만든다.

  - 메모리 = 주기억장치 RAM 램(= 작업공간, 따라서 다다익램)

    - 메모리 크기 => 내가 작업하고 있는 책상의 넓이
    - 하드 디스크의 용량 = > 책상 서랍
    - Loading 때는 보조기억장치에 있는 것을 메모리에 올려준다(메모리 공간에 안착하게 함)

  - 값이 없으면 앱이 죽는 Crach 가 난다.

    - 0은 값이 없는게 아니고 0 이다.

      - 1는 물리적
      - 없다는 완벽한 값이 없는것
      - 0은 0이라는 값이 들어 있는것

      램 관리(= 책상정리)주체는 운영체제

    - 운영체제가 왜 나왔을까? 사용자가 알필요가 없는것을 몽땅 관리할 수 있게 나온 체제(정확히 운영체제 커널)

    - Crach는 운영체제가 죽여버리는 것이다. (빈공간에 들어가 무슨 짓을 할지 모르므로 관리적으로 죽여버림)

    - **결론적으로 swift에서는 될 수 있으면 빈공간을 사용하지 말자가 기본**

    - 옵셔널이 아닌 모든 공간이 빈공간이 아니다. 그것을 보장하는 것이 swift 언어의 철칙이다.

    - 어떤 변수든 간에 빈공간이 아닌 상태로 있어야한다.

    - 코드 어디선가 nil을 봤으면 그 공간은 무조건 Optional 이다.

    

- State 와 Status 차이:

  - State: **현재의 상태**를 의미한다.

  - Status: **결과로서의 상태**를 의미한다. 좀 더 알아보면, 경과의 의미를 갖을때 사용할 수 있다.(ex. 주문 상태)

    - label이 보이는지 안 보이는지 상태를 나타내는 변수

    ```swift
    var labelVisibilityState
    ```

    - 결제 프로세스 상태를 갖는 변수

    ```swift
    var paymentProcessStatus
    ```

    과정 중 상태가 완료된 것은 `status`, 상태가 계속 바뀌는 것은 `state`를 사용할 수 있다.

    

- CPU의 구성요소

  - Cache

    `주기억 장치와 중앙처리장치 사이`에 있는 `데이터를 저장해두는 임시장소`

    캐시는 주기억장치와 중앙처리장치 사이에 있는 고속 버퍼 메모리로, 용량은 적지만 속도가 빨라서 데이터에 접근하기에 좋습니다.

    - L1 Cache: 프로세서와 가장 가까운 캐시. 속도를 위해 I$와 D$로 나뉜다.
      - Instruction Cache (I$): 메모리의 TEXT 영역 데이터를 다루는 캐시.
      - Data Cache (D$): TEXT 영역을 제외한 모든 데이터를 다루는 캐시.
        - 캐시에 달러 기호($)를 사용하는 이유는 캐시(Cache)의 발음이 현금을 뜻하는 'Cash’와 같기 때문이다
    - L2 Cache: 용량이 큰 캐시. 크기를 위해 L1 캐시처럼 나누지 않는다.
    - L3 Cache: 멀티 코어 시스템에서 여러 코어가 공유하는 캐시.

  - ALU

    **산술 논리 장치**

    (Arithmetic logic unit): 디지털 회로의 하나

    - **산술 논리 장치**(算術論理裝置, arithmetic logic unit)는 두 숫자의 (덧셈, 뺄셈같은) 산술연산과 (배타적 논리합, 논리곱, 논리합같은) 논리연산을 계산하는 디지털 회로이다. 산술논리장치는 컴퓨터 중앙처리장치의 기본 설계 블록이다.

  - Control Unit(제어 유닛): **제어 장치**(control unit, CU)는 프로세서의 조작을 지시하는 컴퓨터 중앙 처리 장치(CPU)의 한 부품이다. 입출력 장치 간 통신 및 조율을 제어한다

- Linux는 컴퓨터의 운영체제(OS)가 아닌 **커널**이다.
  - 커널: 커널은 운영 체제의 핵심 부분이므로, 커널의 역할 역시 운영 체제의 핵심 역할이라 할 수 있다.
    - 보안 : 커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.
    - 자원 관리: 한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다. 특히 프로세스에 처리기를 할당하는 것을 스케줄링이라 한다.
    - 추상화: 같은 종류의 부품에 대해 다양한 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 문제를 매우 복잡하게 만들 수 있다. 일반적으로 커널은 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 몇 가지 하드웨어 추상화(같은 종류의 장비에 대한 공통 명령어의 집합)들로 구현된다. 이 하드웨어 추상화는 프로그래머가 여러 장비에서 작동하는 프로그램을 개발하는 것을 돕는다. 하드웨어 추상화 계층(HAL)은 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의지한다.

- 숫자야구게임 [STEP 2] 피드백 수정 및 리펙토링

  - Naming

  - 줄 바꿈

  - contains -> set 중복 비교 로직 교체

  - `guard let` vs `if let`

    `guard` 뒤에 따라붙는 코드의 실행 결과가 true일 때 코드가 계속 실행됩니다.
    if 구문과는 다르게 `guard` 구문은 항상 `else` 구문이 뒤에 따라와야 합니다.
    만약 **guard 뒤 따라오는 `Bool`** 값이 false라면 else의 블록 내부 코드를 실행하게 됩니다.
    이 내부 코드에는 자신보다 **상위 코드 블록을 종료하는 코드**가 반드시 들어가게 됩니다.
    코드 블록 종료시 `return, break, continue, throw` 등 제어문 전환 명령을 사용합니다.

    Bool타입의 값으로 guard문 동작시킬 수 있지만 **`옵셔널 바인딩`** 역할도 가능합니다.
    이렇게 사용시 `guard로 옵셔널 바인딩 된 상수`를 guard 구문 실행 코드 아래부터 **`함수 내부의 지역상수`처럼 사용 가능합니다.**

    guard let으로 할 경우 ','(쉼표)로 `추가조건`을 나열할 수 있고 조건은 `Bool 타입` 값이어야 합니다. ','로 나열했을 때 `AND 논리연산자`와 같은 결과이고, ','를 '&&' 로 치환 가능

    ### **장점**

    guard 구문 사용시 if 코드를 훨씬 간결하고 읽기 좋게 구성 가능합니다.
    예외사항만을 처리하고 싶다면 guard 구문을 사용하는 것이 훨씬 간편합니다.

    ### **단,**

    `guard`는 return,break,continue,throw 등의 `제어문 전환 명령어`를 쓸 수 없는 상황이라면 사용이 불가능합니다. 함수나 메서드, 반복문 등 `특정 블록 내부`에 위치하지 않는다면 사용이 제한됩니다.

    ### if let

    if let로 옵셔널 바인딩 된 상수는 그 블럭 안에서만 변수가 사용 가능합니다

    > 출쳐 : [gurad let과 if let](https://velog.io/@dev-lena/guard-let과-if-let의-차이점)

---

### 문제점 / 고민한 점 🤦🏼

- 숫자야구게임 코드를 리뷰 받으면서 코드 네이밍에 대해 `james`와 고민을 많이 했습니다.

  > 주석이 없어도 한번에 무슨 동작을 하는지 알아야 된다.

---

### 해결방법 🙋🏼

- API Design Guidelines
- Swift Style Guide

> 코드의 네이밍, 띄어쓰기, 줄 바꿈에 대해 생각을 바꾸게 되었습니다.
>
> 내가 생각하는 가독성보다는 보편적인 코드 법칙을 따르자! 





